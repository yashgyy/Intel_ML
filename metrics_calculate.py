import pandas as pd
import numpy as np

def calculate_performance_metrics(input_file, output_file):
    """
    Reads a CSV file with hardware performance counters, calculates key metrics,
    and saves the results to a new CSV file.

    Args:
        input_file (str): The path to the input CSV file.
        output_file (str): The path where the output CSV file will be saved.
    """
    try:
        df = pd.read_csv(input_file)
    except FileNotFoundError:
        print(f"Error: The file '{input_file}' was not found.")
        return

    # --- Clean up column names for easier access ---
    # The prefix "Hardware Event Count:" is removed from each column name.
    df.columns = df.columns.str.replace('Hardware Event Count:', '')

    # --- Create a new DataFrame to store the results ---
    results_df = pd.DataFrame()
    results_df['PID'] = df['PID']

    # --- Define a safe division function to prevent ZeroDivisionError ---
    def safe_divide(numerator, denominator):
        # Use numpy to handle division by zero, returning 0 instead of an error.
        return np.divide(numerator, denominator, out=np.zeros_like(numerator, dtype=float), where=(denominator != 0))

    # --- 1. Calculate IPC (Instructions Per Cycle) ---
    results_df['IPC'] = safe_divide(df['INST_RETIRED.ANY'], df['CPU_CLK_UNHALTED.THREAD'])

    # --- 2. Calculate L1 Instruction Cache (IC) Hit % ---
    # We use FRONTEND_RETIRED.ANY_DSB_MISS as a proxy for L1I misses.
    ic_misses = df['FRONTEND_RETIRED.ANY_DSB_MISS']
    instructions = df['INST_RETIRED.ANY']
    ic_miss_rate = safe_divide(ic_misses, instructions)
    results_df['IC_Hit_%'] = (1 - ic_miss_rate) * 100

    # --- 3. Calculate L1 Data Cache (DC) Hit % ---
    l1d_hits = df['MEM_LOAD_RETIRED.L1_HIT']
    l1d_misses = df['MEM_LOAD_RETIRED.L1_MISS']
    total_l1d_accesses = l1d_hits + l1d_misses
    results_df['DC_Hit_%'] = safe_divide(l1d_hits, total_l1d_accesses) * 100

    # --- 4. Calculate L2 Cache Hit % ---
    # L2 hits from data cache misses
    l2_hits_from_dc_miss = df['MEM_LOAD_RETIRED.L2_HIT']
    
    # L2 hits from instruction cache misses
    l1i_misses_that_hit_l2 = df['FRONTEND_RETIRED.ANY_DSB_MISS'] - df['FRONTEND_RETIRED.L2_MISS']
    
    total_l2_hits = l2_hits_from_dc_miss + l1i_misses_that_hit_l2
    total_l2_accesses = df['MEM_LOAD_RETIRED.L1_MISS'] + df['FRONTEND_RETIRED.ANY_DSB_MISS']
    results_df['L2_Hit_%'] = safe_divide(total_l2_hits, total_l2_accesses) * 100

    # --- 5. Calculate L3 Cache Hit % ---
    # This is the hit rate for requests that already missed L1 and L2.
    l3_hits = df['MEM_LOAD_RETIRED.L3_HIT']
    l3_misses = df['MEM_LOAD_RETIRED.L3_MISS']
    total_l3_accesses = l3_hits + l3_misses
    results_df['L3_Hit_%'] = safe_divide(l3_hits, total_l3_accesses) * 100
    
    # --- 6. Breakdown of L2 Hits ---
    results_df['L2_Hits_from_DC_Miss'] = l2_hits_from_dc_miss
    results_df['L2_Hits_from_IC_Miss'] = l1i_misses_that_hit_l2
    # Note: Hits from prefetch cannot be calculated with the given counters.

    # --- 7. Memory Bandwidth ---
    CACHE_LINE_SIZE = 64
    cycles = df['CPU_CLK_UNHALTED.THREAD']

    # 7a. Calculate Demand Read Bandwidth (from L3 misses)
    bytes_read_from_mem = df['MEM_LOAD_RETIRED.L3_MISS'] * CACHE_LINE_SIZE
    results_df['Demand_Read_Bandwidth_Bytes_per_Cycle'] = safe_divide(bytes_read_from_mem, cycles)

    # 7b. Calculate Write Bandwidth (approximated from L2 RFOs)
    # An RFO (Request For Ownership) is issued when a core intends to write to a cache line.
    # This approximates the total write pressure generated by the core.
    bytes_written = df['L2_RQSTS.ALL_RFO'] * CACHE_LINE_SIZE
    results_df['Write_Bandwidth_Bytes_per_Cycle'] = safe_divide(bytes_written, cycles)
    
    # --- Save the results to the output file ---
    results_df.to_csv(output_file, index=False)
    print(f"Metrics successfully calculated and saved to '{output_file}'")

# --- Main execution ---
if __name__ == "__main__":
    # Specify the input file from the user and the desired output file name
    INPUT_CSV = 'uarch_workload_main_bandwidth.csv'
    OUTPUT_CSV = 'performance_metrics.csv'
    calculate_performance_metrics(INPUT_CSV, OUTPUT_CSV)